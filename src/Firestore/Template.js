import firebase from 'firebase'
import {firestore, query, collection, where, getAll} from 'firebase/firestore';
import {db, auth, storage} from '../db';

// global err function
function err(e) {
  return {success: false, error: e};
}

/* Upload an image/file to Firebase Storage and download URL to store in question
  - file = e.target.files[0]
         = uploadButton.files[0] (under edit-survey-components Vue files)
  Return the URL of the image

  Called in edit-survey-components' MultiChoice.vue and TextAnswer.vue
*/
async function uploadImage(file) {
  // Create a reference to the Firebase storage service
  var storageRef = firebase.storage().refFromURL("gs://" + storage + "/template_images")
  // Create a reference to the file you want to upload
  var fileRef = storageRef.child(file.name);

  return new Promise((resolve, reject) => {
    // save to storage
    fileRef.put(file).then((snapshot) => {
      var percentage = (snapshot.bytesTransferred / snapshot.totalBytes) * 100;
      if (percentage == 100) {
        // once upload is complete, get image URL
        fileRef.getDownloadURL()
          .then(url => {
            // console.log('Uploaded a file!');
            // console.log("URL: ", url);
            resolve({success: true, url: url});
          })
          .catch(e => reject(err(e)));
      }
      else {
        // error if upload failed
        console.log("Upload didn't complete: " + percentage + "%");
        resolve({success: false, url: ''});
      }
    })
    .catch(e => reject(err(e)));
  });
}

/* Create template with given fields:
   - tID (autogenerated)
   - name
   - tags (array, can have multiple)
   - questions (an array of questions/JSON objects, includes "qType" and "content")
      - question fields:
        - qType ("multi-choice", "multi-select", "text-answer", "linear-scale", or "dropdown")
          - "text" question also includes an "imgSrc" field
          - "multiple choice" includes an array "options", which stores pairs of "imgSrc" and "text"
        - content: contains “title”, "options", etc. see below
    - e.g. questions : [
            {"qType": "multi-choice", "content": {"title": "Multiple Choice", "options": [{"text": "True", "imgSrc": ""}, {"text": "False", "imgSrc": ""}]}},
            {"qType": "multi-select", "content": {"title": "Multiple Select", "options": ["opt1", "opt2", "opt3"]}},
            {"qType": "dropdown", "content": {"title": "Dropdown", "options": ["opt1", "opt2", "opt3", "opt4", "opt5"]}},
            {"qType": "text-answer", "content": {"title": "Text Answer", "imgSrc": ''}},
            {"qType": "linear-scale", "content": {"title": "Linear Scale", "start": 1, "end": 5, "startLabel": "HORRIBLE", "endLabel": "AMAZING"}}
          ]
   - description
 */
async function createTemplate(name, tags, questions, description) {
  return new Promise(async (resolve, reject) => {
    await db.collection("Template").doc().set({
      name,
      name_lower: name.toLowerCase(),
      tags,
      questions,
      description
    })
      .then(() => {
        // console.log("Successfully created new template");
        resolve({ success: true });
      })
      .catch(e => reject(err(e)));
  })
}

/*
Given a template ID, return a list of questions
*/
async function getTemplateQuestions(tID) {
    return new Promise((resolve, reject) => {
        db.collection("Template").doc(tID).get()
        .then(doc => {
            if (doc.data() !== undefined) {
                // console.log(doc.data().questions)
                resolve({success: true, questions: doc.data().questions})
            } else {
                console.log("Template not found")
                resolve({success: false, questions: []})
            }
        })
        .catch(e => reject(err(e)))
    })
}

/*
Returns a sorted list of template objects (include questions, name, description, and tags)
Sorted alphabetically by name in ascending order (case insensitive)
*/
async function getAllTemplates(){

    return new Promise((resolve, reject) => {
        db.collection("Template").orderBy("name_lower", 'asc').get()
        .then(querySnapshot => {
          if (querySnapshot.empty) {
            resolve({success: true, data: []}) /* there is not a single template in the DB */
          } else {
            let templates = [];
            querySnapshot.forEach(doc => {
              let newDoc = {
                tID: doc.id,
                questions: doc.data().questions,
                name: doc.data().name,
                description: doc.data().description,
                tags: doc.data().tags
              };
              templates.push(newDoc)
            })
            resolve({success: true, data: templates})
          }
        })
        .catch(e => reject(err(e)))
      })
}

/* Delete the given template */
async function deleteTemplate(tID) {
  return new Promise(async (resolve, reject) => {
    db.collection("Template").doc(tID).get()
    .then(() => {
      db.collection("Template").doc(tID).delete()
        .then(() => {
          // console.log("template properly deleted");
          resolve({success: true});
        })
        .catch(e => reject(err(e)));
    })
    .catch(e => reject(err(e)));
  });
}

/* Surveys have a similar structure to templates, only that they have extra "gameID" and "testerIDs" fields
   Surveys are always created under a project ("gameID" string should never be empty)
   The IDs of playtesters assigned to this survey are stored in "testerIDs" (an array)
*/
async function createSurvey(name, tags, questions, description, gameID, testerIDs, developerID) {

    return new Promise(async (resolve, reject) => {
        // adding new survey to db
        await db.collection("Survey").doc().set({
            name,
            name_lower: name.toLowerCase(),
            tags,
            questions,
            description,
            gameID,
            testerIDs,
            developerID,
            status: 0
        })
        .then(() => {
            // console.log("Successfully created a new survey")
            resolve({success: true})
        })
        .catch(e => reject(err(e)));

    });
}

/*
Returns a sorted list of survey objects
Sorted alphabetically by name in ascending order (case insensitive)
*/
async function getAllSurveys(){
    return new Promise((resolve, reject) => {
        db.collection("Survey").orderBy("name_lower", 'asc').get()
        .then(querySnapshot => {
          if (querySnapshot.empty) {
            resolve({success: true, data: []}) /* there is not a single Survey in the DB */
          } else {
            let surveys = [];
            querySnapshot.forEach(doc => {
              let newDoc = {
                sID: doc.id,
                name: doc.data().name,
                tags: doc.data().tags,
                questions: doc.data().questions,
                description: doc.data().description,
                gameID: doc.data().gameID,
                testerIDs: doc.data().testerIDs,
                developerID: doc.data().developerID,
                status: doc.data().status,
              };
              surveys.push(newDoc)
            })
            // console.log("Here are all the surveys sorted by survey name:")
            // console.log(surveys)
            resolve({success: true, data: surveys})
          }
        })
        .catch(e => reject(err(e)))
      })
}

/* Returns a sorted list of surveys belonging to a project */
async function getSurveysByGameID(gameID) {
  return new Promise((resolve, reject) => {
    db.collection("Survey").where("gameID", "==", gameID).orderBy("name_lower", 'asc').get()
      .then(querySnapshot => {
        if (querySnapshot.empty) {
          resolve({ success: true, data: [] }) /* there is not a single Survey under given project in the DB */
        } else {
          let surveys = [];
          querySnapshot.forEach(doc => {
            console.log(doc.data())
            let newDoc = {
              sID: doc.id,
              name: doc.data().name,
              tags: doc.data().tags,
              questions: doc.data().questions,
              description: doc.data().description,
              gameID: doc.data().gameID,
              testerIDs: doc.data().testerIDs,
              developerID: doc.data().developerID,
              status: doc.data().status
            };
            surveys.push(newDoc)
          })
          resolve({ success: true, data: surveys })
        }
      })
      .catch(e => reject(err(e)))
  })
}

/* Adds field "name_lower" to each template
   Call in main.js if you want to update templates that don't have this field
   Make sure each document in the database has the field "name"
*/
async function setTemplateNameLower() {

  return new Promise((resolve, reject) => {
    db.collection("Template").get()
      .then(querySnapshot => {
        if (querySnapshot.empty) {
          // console.log("No templates found")
          resolve({ success: true }) /* there is not a single template in the DB */
        } else {
          querySnapshot.forEach(doc => {
            // add "name_lower"
            doc.ref.update({'name_lower': doc.data().name.toLowerCase()})
          })
          // console.log("Successfully added name_lower field")
          resolve({ success: true })
        }
      })
      .catch(e => reject(err(e)))
  })
}

/* Adds field "name_lower" to each survey
   Call in main.js if you want to update surveys that don't have this field
   Make sure each document in the database has the field "name"
*/
async function setSurveyNameLower() {

  return new Promise((resolve, reject) => {
    db.collection("Survey").get()
      .then(querySnapshot => {
        if (querySnapshot.empty) {
          console.log("No surveys found")
          resolve({ success: true }) /* there is not a single survey in the DB */
        } else {
          querySnapshot.forEach(doc => {
            // add "name_lower"
            doc.ref.update({'name_lower': doc.data().name.toLowerCase()})
          })
          // console.log("Successfully added name_lower field")
          resolve({ success: true })
        }
      })
      .catch(e => reject(err(e)))
  })
}

// modify the name of a Survey
async function modifySurveyName(sID, name){
  return new Promise((resolve, reject) => {
    db.collection("Survey").doc(sID).get()
      .then(doc => {
        if (!doc.exists) {
          reject({success: false, error: "Survey being access does not exist"})
        }

        // modifying the name:
        db.collection("Survey").doc(sID)
          .update({name: name, name_lower: name.toLowerCase()})
          .then(() => {
            resolve({success: true});
            // console.log("Survey name changed properly");
          })
          .catch(e => reject(err(e)))
      })
      .catch(e => reject(err(e)))
  })
}

// modify the tags of a Survey
async function modifySurveyTags(sID, tags){
  // check if the Survey exists
  return new Promise((resolve, reject) => {
    db.collection("Survey").doc(sID).get()
      .then(doc => {
        if (!doc.exists) {
          reject({success: false, error: "survey doesn't exist"})
        }
        // update the Survey tags
        db.collection("Survey").doc(sID)
          .update({
            tags: tags
          })
          .then(() => {
            resolve({success: true});
            // console.log("Survey tags modified properly");
          })
          .catch(e => reject(err(e)))
      })
      .catch(e => reject(err(e)))
  })
}


// modify the questions within a Survey
async function modifySurveyQuestions(sID, questions){
  // check if the Survey exists
  return new Promise((resolve, reject) => {
    db.collection("Survey").doc(sID).get()
      .then(doc => {
        if (!doc.exists) {
          reject({success: false, error: "survey doesn't exist"})
        }
        // update the Survey tags
        db.collection("Survey").doc(sID)
          .update({
            questions: questions
          })
          .then(() => {
            resolve({success: true});
            // console.log("Survey questions modified properly");
          })
          .catch(e => reject(err(e)))
      })
      .catch(e => reject(err(e)))
  })
}

// modify the description of a Survey
async function modifySurveyDescription(sID, description){
  // check if the Survey exists
  return new Promise((resolve, reject) => {
    db.collection("Survey").doc(sID).get()
      .then(doc => {
        if (!doc.exists) {
          reject({success: false, error: "survey doesn't exist"})
        }
        // update the Survey tags
        db.collection("Survey").doc(sID)
          .update({
            description: description
          })
          .then(() => {
            resolve({success: true});
            // console.log("Survey description modified properly");
          })
          .catch(e => reject(err(e)))
      })
      .catch(e => reject(err(e)))
  })
}

// modify the description of a Survey
async function modifySurveyTesterIDs(sID, testerIDs){
  // check if the Survey exists
  return new Promise((resolve, reject) => {
    db.collection("Survey").doc(sID).get()
      .then(doc => {
        if (!doc.exists) {
          reject({success: false, error: "survey doesn't exist"})
        }
        // update the Survey tags
        db.collection("Survey").doc(sID)
          .update({
            testerIDs: testerIDs
          })
          .then(() => {
            resolve({success: true});
            // console.log("Survey testerIDs modified properly");
          })
          .catch(e => reject(err(e)))
      })
      .catch(e => reject(err(e)))
  })
}


// set a status to the given Survey, status is an int with a value of 0, 1 or 2 only
async function setSurveyStatus(sID, status){
  // check if the Survey exists
  return new Promise((resolve, reject) => {
    db.collection("Survey").doc(sID).get()
      .then(doc => {
        if (!doc.exists) {
          reject({success: false, error: "survey doesn't exist"})
        }
        // update the Survey tags
        db.collection("Survey").doc(sID)
          .update({
            status: status
          })
          .then(() => {
            resolve({success: true});
            // console.log("Survey status set properly");
          })
          .catch(e => reject(err(e)))
      })
      .catch(e => reject(err(e)))
  })
}

async function deleteSurvey(sID){
  return new Promise(async (resolve, reject) => {
    // catch the specific survey object and name it surveyDocRef
    db.collection("Survey").doc(sID).get()
    .then(() => {
      db.collection("Survey").doc(sID).delete()
        .then(() => {
          // console.log("survey properly deleted");
          resolve({success: true});
        })
        .catch(e => reject(err(e)));
    })
    .catch(e => reject(err(e)));
  });
}

export default {
  uploadImage,
  createTemplate,
  getTemplateQuestions,
  getAllTemplates,
  deleteTemplate,
  createSurvey,
  getAllSurveys,
  getSurveysByGameID,
  setTemplateNameLower,
  setSurveyNameLower,
  modifySurveyName,
  modifySurveyTags,
  modifySurveyQuestions,
  modifySurveyDescription,
  modifySurveyTesterIDs,
  setSurveyStatus,
  deleteSurvey, 
}
